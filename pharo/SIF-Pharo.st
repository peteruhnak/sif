SmalltalkInterchangeFileInManager subclass: #SmalltalkInterchangePharoFileInManager	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SIF-Pharo'!!SmalltalkInterchangePharoFileInManager methodsFor: 'streaming' stamp: 'EAT 2/9/2000 17:31'!newStreamOnFileNamed: file	"	file	<String>		^	<ReadStream>	Return a stream that is opened on the file named file.	If I am meant to write them return a write stream, read then a read strea."	(FileStream isAFileNamed: self fileName) ifFalse: [		self error: 'Non-existent file named: ', self fileName printString].	^FileStream readOnlyFileNamed: self fileName! !!SmalltalkInterchangePharoFileInManager methodsFor: 'streaming' stamp: 'EAT 2/11/2000 14:10'!nextWord	"	^			<String> | nil	Return the next word found on my managed stream.  If I reach the end of the stream before	finding a word, then return nil.	I skip any current whitespcae, start collecting, and stop at the first white space."	"| s m |	s := ReadStream on: 'hello world'.	m := SmalltalkInterchangePharoFileInManager new.	m nextWordOn: s.	m nextWordOn: s"	| result done next |	self skipWhiteSpace.	done := false.	result := WriteStream on: (String new: 32).	[self atEnd or: [done]] whileFalse: [		next := self managedStream next.		next isSeparator			ifTrue: [				done := true.				self managedStream skip: -1]			ifFalse: [result nextPut: next]].	result size = 0 ifTrue: [		^nil].	^result contents! !!SmalltalkInterchangePharoFileInManager methodsFor: 'file in' stamp: 'EAT 2/9/2000 16:17'!fileInClassItem: item	"	item	<SmalltalkInterchangeFileItem>		^	void	item is a class item that needs to be processed.	Item attributes:	Item attributes:		name				<String> 'named:'		superclassName		<String> 'superclass:'		instVarType			#none | #byte | #object 'indexedInstanceVariables:'		instVarNames		<String>'instanceVariableNames:'		classVarNames		<String> 'classVariableNames:'		sharedPoolNames	<String> 'sharedPools:'		classInstVarNames	<String> 'classInstanceVariableNames:'	item annotations		package	"	| result package |	item instVarType == #none ifFalse: [		item instVarType == #byte ifTrue: [].		item instVarType == #object ifTrue: [].		self error: 'Have not added support for variable subclasses yet'].	package := (package := item packageAnnotation) isNil		ifTrue: ['None Specified-SIF']		ifFalse: [package value].	result := (Smalltalk at: item superclassName asSymbol)		subclass: item name asSymbol		instanceVariableNames: item instVarNames		classVariableNames: item classVarNames		poolDictionaries: item sharedPoolNames		category: package.	result class instanceVariableNames: item classInstVarNames.! !!SmalltalkInterchangePharoFileInManager methodsFor: 'file in' stamp: 'EAT 2/9/2000 17:24'!fileInMethodItem: item intoClass: class	"	item	<SmalltalkInterchangeFileItem>		^	void	item is a smalltalk item that needs to be processed.	Item attributes:		firstToken		Class name		value		Source string	item annotations		category		categories		package"	| method |	method := item categoryAnnotation isNil		ifTrue: [class compile: item value notifying: nil]		ifFalse: [class compile: item value classified: item categoryAnnotation value].	method isNil ifTrue: [		self error: 'Compile error.'].! !!SmalltalkInterchangePharoFileInManager methodsFor: 'file in' stamp: 'EAT 2/12/2000 01:21'!handleAnnotationsOnGlobalInitializerItem: item	"	item	<SmalltalkInterchangeFileItem>		^	void	item is an initializer item that needs to be processed.  I am called by the generic handler	in order to handle the annotations on the item.	Item attributes:		firstToken		Global name		value		Code to eval	item annotations		Package-PreInstallCode		Package-PreUnInstallCode		Package-PostInstallCode		Package-PosUntInstallCode"	| annotation missing |	annotation := item annotationNamed: 'package-preRequisites'.	annotation isNil ifFalse: [		missing := Set new.		(self collectionOfStringsFrom: annotation value) do: [:each |			(SystemOrganization categories includes: each) ifFalse: [				missing add: each]].		missing isEmpty ifFalse: [			Transcript cr; show: '### SIF: Missing pre-requisites:'.			missing asSortedCollection do: [:each |				Transcript cr; tab; show: each]]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmalltalkInterchangePharoFileInManager class	instanceVariableNames: ''!!SmalltalkInterchangePharoFileInManager class methodsFor: 'initializing' stamp: 'EAT 2/11/2000 14:33'!bootstrap	"	SmalltalkInterchangeFileManager newForFileIn		fileName: 'C:\Dev\Dolphin Smalltalk 98\sif-support.sif';		fileIn	SmalltalkInterchangeFileManager newForFileIn		fileName: 'C:\Dev\Dolphin Smalltalk 98\SifTestAll.sif';		fileIn	"! !!SmalltalkInterchangePharoFileInManager class methodsFor: 'initializing' stamp: 'EAT 2/9/2000 22:23'!initialize	"	^	self	Initialize everything that is needed for my being used by the Pharo dialect."	"	SmalltalkInterchangePharoFileInManager initialize	"		"This is here only to allow the file in of the code to put the			do it to init me."	super initialize.! !SmalltalkInterchangePharoFileInManager initialize!SmalltalkInterchangeFileOutManager subclass: #SmalltalkInterchangePharoFileOutManager	instanceVariableNames: 'mostRecentClasses '	classVariableNames: ''	poolDictionaries: ''	category: 'SIF-Pharo'!!SmalltalkInterchangePharoFileOutManager methodsFor: 'accessing' stamp: 'EAT 2/11/2000 14:12'!classOfBehavior: class	"	class		<Behavior>		^		<Class>	If class is a Class then return it, if not then class is a metaclass,	return it's sole instance."	"	SmalltalkInterchangePharoFileOutManager new classOfBehavior: Class	SmalltalkInterchangePharoFileOutManager new classOfBehavior: Class class	"	^class isMeta		ifTrue: [class soleInstance]		ifFalse: [class]! !!SmalltalkInterchangePharoFileOutManager methodsFor: 'fileout info' stamp: 'EAT 2/11/2000 15:06'!classDefinitionInfoFor: class	"	class	<Behavior>		^		<Dictionary key: <Symbol> value: <String>>	Return info on		#name			<String>		#superclassName	<String>		#instVarType		#byte | #object | #none		#instVarNames		<Array withAll: <String>>		#classVarNames		<Array withAll: <String>>		#poolVarNames		<Array withAll: <String>>		#classInstVarNames	<Array withAll: <String>>		#annotations		<Dictionary key: <String> value: <String>>	"	^Dictionary new		at: #name put: class name asString;		at: #superclassName put: (class superclass isNil ifTrue: [''] ifFalse: [class superclass name asString]);		at: #instVarType put: (class isVariable			ifTrue: [ 				class isBytes 					ifTrue: [#byte]					ifFalse: [#object] ]			ifFalse: [#none]);		at: #instVarNames put: class instVarNames;		at: #classVarNames put: class classVarNames;		at: #poolVarNames put: class sharedPools;		at: #classInstVarNames put: class class instVarNames;		at: #annotations put: (Dictionary new			"at: 'comment' put: '';."			at: 'package' put: class category asString;			yourself);		yourself! !!SmalltalkInterchangePharoFileOutManager methodsFor: 'fileout info' stamp: 'EAT 2/11/2000 14:21'!methodItemInfoFor: methodName ofClass: class	"	methodName	<Symbol>		class			<Behavior>		^		<Dictionary key: <Symbol> value: <Object>>	Return info on method		#className	<String>		#isClassMethod	<Boolean>		#source		<String>		#annotations	<Dictionary key: <String> value: <String?	"	| result |	result := Dictionary new.	result at: #className put: (self nameForClass: class);		at: #isClassMethod put: class isMeta.	(result at: #source put: (class compiledMethodAt: methodName) getSourceFromFile) isNil ifTrue: [		self error: 'There is no source for this method'].	result at: #source put: (result at: #source) asString.	result at: #annotations put: (Dictionary new		at: 'category' put: (class whichCategoryIncludesSelector: methodName) asString;		yourself).	^result! !!SmalltalkInterchangePharoFileOutManager methodsFor: 'fileout info' stamp: 'EAT 2/11/2000 15:10'!packageItemInfoFor: name	"	name	<String>		^		<Dictionary key: <Symbol> value: <Object>>	Return info on the package named name		#name			<String>		#classes			<Class>		#methods			<Collection withAll: <CompiledMethod>>		#preInstallCode		<String>		#postInstallCode		<String>		#preUnInsrallCode	<String>		#postUninstallCode	<String>	"	| methods eachClass |	methods := OrderedCollection new: 64.	(SystemOrganization listAtCategoryNamed: name asSymbol) do: [:eachClassName |		eachClass := Smalltalk at: eachClassName.		eachClass selectors do: [:each |			methods add: (Array with: each with: eachClass)]].	^Dictionary new		at: #name put: name;		at: #classes put: ((SystemOrganization listAtCategoryNamed: name asSymbol)			collect: [:each | Smalltalk at: each]);		at: #methods put: methods;		at: #preInstallCode put: '';		at: #postInstallCode put: '';		at: #preUnInstallCode put: '';		at: #postUnInstallCode put: '';		yourself! !!SmalltalkInterchangePharoFileOutManager methodsFor: 'fileout info' stamp: 'EAT 2/9/2000 21:05'!poolVariableItemInfoFor: variableName in: pool	"	variableName	<String>		pool			<Dictionary key: <String> value: <Object>>		^		<Dictionary key: <Symbol> value: <Object>>	Return info on method		#isConstant	<Boolean>		#initializer		<String>	"	^Dictionary new		at: #isConstant put: false;		at: #initializer put: (pool at: variableName) printString;		yourself! !!SmalltalkInterchangePharoFileOutManager methodsFor: 'streaming' stamp: 'EAT 2/9/2000 21:07'!newStreamOnFileNamed: file	"	file	<String>		^	<WriteStream>	Return a stream that is opened on the file named file.	If I am meant to write them return a write stream, read then a read strea."	^FileStream newFileNamed: file! !!SmalltalkInterchangePharoFileOutManager methodsFor: 'streaming' stamp: 'EAT 2/11/2000 15:16'!nextSymbolPutString: string	"	string		<String>	"	self nextPut: $#.	^super nextSymbolPutString: string! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmalltalkInterchangePharoFileOutManager class	instanceVariableNames: ''!!SmalltalkInterchangePharoFileOutManager class methodsFor: 'initializing' stamp: 'EAT 2/9/2000 22:23'!initialize	"	^	self	Initialize everything that is needed for my being used by the Pharo dialect."	"	SmalltalkInterchangePharoFileOutManager initialize	"		"This is here only to allow the file in of the code to put the			do it to init me."	super initialize.! !SmalltalkInterchangePharoFileOutManager initialize!